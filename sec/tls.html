<!DOCTYPE html>
<html lang="ru"
>
<head>
    <title>Что такое SSL? - NX</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://blog.hoxnox.com/sec/tls.html">

        <meta name="author" content="hoxnox@gmail.com" />
        <meta name="keywords" content="ssl,tls,security,cryptography" />
        <meta name="description" content="Описание протокола TLS на основе RFC-5246" />

    <!-- Enable latex plugin -->




    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://blog.hoxnox.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://blog.hoxnox.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://blog.hoxnox.com/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://blog.hoxnox.com/theme/css/style.css" type="text/css"/>

        <link href="http://blog.hoxnox.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="NX ATOM Feed"/>
        <link href="http://blog.hoxnox.com/rss.xml" type="application/rss+xml" rel="alternate"
              title="NX RSS Feed"/>


        <link href="http://blog.hoxnox.com/feeds/sec.atom.xml" type="application/atom+xml" rel="alternate"
              title="NX sec ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://blog.hoxnox.com/" class="navbar-brand">
NX            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://blog.hoxnox.com/category/admin.html">Admin</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/blog.html">Blog</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/chsheets.html">Chsheets</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/cxx.html">Cxx</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/devel.html">Devel</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/gentoo.html">Gentoo</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/inet.html">Inet</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/other.html">Other</a>
                        </li>
                        <li class="active">
                            <a href="http://blog.hoxnox.com/category/sec.html">Sec</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li><a href="http://blog.hoxnox.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
        <div class="col-sm-9">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://blog.hoxnox.com/sec/tls.html"
                       rel="bookmark"
                       title="Permalink to Что такое SSL?">
                        Что такое SSL?
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2012-08-14T00:00:00+04:00"> Вт 14 Август 2012</time>
    </span>






<span class="label label-default">Tags</span>
	<a href="http://blog.hoxnox.com/tag/ssl.html">ssl</a>
        /
	<a href="http://blog.hoxnox.com/tag/tls.html">tls</a>
        /
	<a href="http://blog.hoxnox.com/tag/security.html">security</a>
        /
	<a href="http://blog.hoxnox.com/tag/cryptography.html">cryptography</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>SSL - это протокол, позволяющий устанавливать защищенные соединения. На основе SSL 3.0 был
разработан TLS. Сейчас, когда говорят об SSL имеют ввиду TLS. TLS - основа безопасности в Интернете.</p>
<p>Как только клиент и сервер решили общаться по протоколу SSL, первое что они делают - процедура
установления соединения (рукопожатие - handshake).</p>
<div class="section" id="id1">
<h2>Общие понятия</h2>
<div class="section" id="id2">
<h3>Число</h3>
<p>Все данные, представляемые в протоколе записываются в прямом порядке байт. То есть</p>
<div class="highlight"><pre><span></span>value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) | ... | byte[n-1];
</pre></div>
</div>
<div class="section" id="id3">
<h3>Вектор</h3>
<p>Запись вида</p>
<div class="highlight"><pre><span></span>T T&#39;[n];
</pre></div>
<p>означает определение нового типа T', который является вектором значений типа T фиксированной длины
n. При этом n - <strong>количество байт</strong>, занимаемых новым типом T'.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Ещё раз повторюсь - КОЛИЧЕСТВО БАЙТ! Причем логично, что n должно быть кратно размеру T.</td>
</tr>
</tbody>
</table>
<p>Пример:</p>
<div class="highlight"><pre><span></span>opaque Datum[3]; /* Три байта, не интерпретируемые протоколом */
Datum Data[9]; /* 9-байтный вектор значений типа Datum.*/

/*
На C эта запись выглядела бы так:

typedef opaque[3] Datum;
Datum Data[3];
*/
</pre></div>
<!-- *** -->
<p>Существует такое понятие как <em>вектор переменной длины</em>. Определение нового типа T' - вектор
переменной длины от K до N байт, содержащий значения типа T.</p>
<div class="highlight"><pre><span></span>T T&#39;&lt;K..N&gt;
</pre></div>
<p>При кодировании таких векторов дополнительно приписывается его текущая длина. Записывается она в
виде числа из M байт, где M - число байт, достаточных для хранения числа, отражающего максимальную
длину вектора в байтах. Например:</p>
<div class="highlight"><pre><span></span>opaque mandatory&lt;300..400&gt;;
 /* вектор не менее 300, но не более 400 байт. Длина записывается числом в 2 байта (достаточно для
 хранения числа 400.*/
uint16 longer&lt;0..800&gt;
 /* вектор чисел типа uint16 с максимальной длиной в 800 байт (то есть может содержать не более
 400 элементов типа uint16. Может быть пустым. Длина записывается числом в 2 байта.*/
</pre></div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Как и с вектором фиксированной длины, реальная длина должна быть делителем размера T. То есть
не может существовать 17-байтного вектора чисел uint16.</td>
</tr>
</tbody>
</table>
<p>Базовый тип данных - uint8. Определены также</p>
<div class="highlight"><pre><span></span>uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];
</pre></div>
<p>В случае представления целого числа в виде вектора байт он представляется как без знаковое целое без
лидирующего ноля.</p>
</div>
<div class="section" id="id4">
<h3>Перечисление</h3>
<p>Аналогично языку си:</p>
<div class="highlight"><pre><span></span>enum { e1(v1), e2(v2), ..., en(vn) [[, (k)]] } Te;
</pre></div>
<p>Соответственно объем, занимаемый одним значением типа &quot;перечисление&quot;, равен числу байт, необходимых
для хранения максимального значения перечисления.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Для задания конкретного числа байт, необходимого для хранения перечисления и служит
необязательный параметр n в определении.</td>
</tr>
</tbody>
</table>
<p>Пример:</p>
<div class="highlight"><pre><span></span>enum { red(3), green(23), blue(1) } Color;

Color color = Color.blue;
Color color = blue;
</pre></div>
<p>Для перечислений, которые никогда не интерпретируются своими значениями последние можно опустить.
Например:</p>
<div class="highlight"><pre><span></span>enum{ low, medium, high } Amount;
</pre></div>
</div>
<div class="section" id="id5">
<h3>Структура</h3>
<p>Аналогично языку си:</p>
<div class="highlight"><pre><span></span>struct {
        T1 t1;
        T2 t2;
        ...
        Tn tn;
} [[T]];
</pre></div>
</div>
<div class="section" id="id6">
<h3>Вариант</h3>
<p>Поля структуры могут варьироваться в соответствии с каким-либо перечислимым типом.</p>
<div class="highlight"><pre><span></span>enum { e1, e2, ..., ek } E;
struct P
        T1 t1;
        T2 t2;
        ...
        Tn tn;
        select (E) {
                case e1: Te1;
                case e2: Te2;
                case e3: case e4: Te3;
                ...
                case en: Ten;
        } [[fv]];
} [[Tv]];
</pre></div>
<p>Например, мы можем определить структуру транспорт с полями &quot;скорость движения&quot; и &quot;количество мест&quot;. Если
это автомобиль, то структура будет содержать поле &quot;объем двигателя&quot;, а для велосипеда определим
&quot;количество скоростей&quot;.</p>
<div class="highlight"><pre><span></span>enum { auto, bicycle } TransportType;

struct Transport {
        int16 speed;
        int8  seats;
        select (TransportType) {
                case auto:
                        int8 engine_capacity;
                case bicycle:
                        int8 gears_count;
        }
}
</pre></div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">в отличии от си перечисления срабатывают одновременно только если они пустые (нет
необходимости в конструкции подобной break)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id7">
<h2>Кодирование криптографических опреаций</h2>
<div class="section" id="id8">
<h3>Цифровая подпись</h3>
<div class="highlight"><pre><span></span>struct {
        SignatureAndHashAlgorithm algorithm;
        opaque signature&lt;0..2^16-1&gt;;
} DigitallySigned;
</pre></div>
</div>
</div>
<div class="section" id="tls-tls-record">
<h2>Протокол TLS записи (TLS Record)</h2>
<p>Протокол TLS записи является многоуровневым. На каждом уровне сообщения могут иметь поля длины,
описания и содержимого (контента).</p>
<p>На вход протокола подаются сообщения, он формирует из них блоки,
упаковывает (опционально), добавляет имитовставку, шифрует и передает результат. Полученные данные
расшифровываются, проверяются, распаковываются, собираются и доставляются клиенту на более высокий
уровень.</p>
<p>Протокол TLS записи используют более сложные протоколы, в зависимости от типа содержимого различают
следующие:
* протокол установления соединения (<em>handshake protocol</em>)
* протокол тревоги (<em>alert protocol</em>)
* протокол изменения параметров шифрования (<em>change cipher spec protocol</em>)
* протокол данных приложения (<em>application data protocol</em>)</p>
<p>Существует процедура описания новых типов содержимого и регистрации их (посредством IANA) в реестре
типов содержимого, в результате чего TLS является расширяемым. Если тип содержимого неизвестен, в
обязательном порядке отправляется сигнал unexpected_message.</p>
<p>При проектировании протокола, основывающегося на TLS разработчик должен четко понимать от чего TLS
защищает, а от чего нет. К примеру, тип и длина записи не защищены шифрованием. Если эта информация
должна быть спрятана, об этом должен позаботиться разработчик.</p>
</div>
<div class="section" id="id9">
<h2>Хеш-код идентификации сообщений и псевдослучайная функция</h2>
<p>TODO: стр. 14</p>
<p>Как упоминалось выше, на уровне TLS записи используется имитовставка для защиты целостности
сообщений. В качестве имитовставки в алгоритмах, описанных RFC-5246 используется HMAC
(хеш-имитовставка). Дополнительно, необходима конструкция, которая дополняла бы ключи до блоков,
достаточных для генерации ключа или валидации?!</p>
</div>
<div class="section" id="id10">
<h2>Состояния соединения</h2>
<p>Состояние TLS соединения определяет алгоритм сжатия, шифрования, имитовставки, а также параметры
алгоритмов - ключ имитовставки и ключи шифрования как на запись, так и на чтение. Выделяют 4
состояния соединения:</p>
<ol class="arabic simple">
<li>current_write</li>
<li>current_read</li>
<li>pending_write</li>
<li>pending_read</li>
</ol>
<p>Обработка всех сообщений производится в текущих состояниях (первые два). Параметры ожидающих
состояний (последние два) могут быть установлены с помощью протокола установления соединения (handshake
protcol), а затем по протоколу изменения параметров шифрования ожидающее состояние может заместить
текущее, которое в свою очередь очищается.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Не позволяется делать замещение текущего состояния ожидаемым, если ожидаемое не было
инициализировано соответствующими параметрами.</td>
</tr>
</tbody>
</table>
<p>Параметры TLS соединения:</p>
<ul>
<li><p class="first">connection end (оконечная точка соединения)
Является ли сущность клиентом или сервером в данном соединении.</p>
<div class="highlight"><pre><span></span>enum { server, client } ConnectionEnd;
</pre></div>
</li>
<li><p class="first">PRF algorithm (псевдослучайная функция)
Алгоритм, используемый для генерации ключей из главного ключа (master key).</p>
<div class="highlight"><pre><span></span>enum{ tls_prf_sha256 } PRFAlgorithm;
</pre></div>
</li>
<li><p class="first">bulk encryption algorithm (алгоритм шифрования)
Спецификация включает в себя размер ключа, является ли шифрование блочными или AEAD, размер блока
шифра (если имеется), и длины явного и неявного инициализирующих векторов.</p>
<div class="highlight"><pre><span></span>enum { null, rc4, 3des, aes } BulkCipherAlgorithm;
</pre></div>
</li>
<li><p class="first">MAC algorithm (алгоритм имитовставки)
Спецификация включает размер значения, возвращаемого алгоритмом.</p>
<div class="highlight"><pre><span></span>enum { stream, block, aead } CipherType;
</pre></div>
</li>
<li><p class="first">compression algorithm (алгоритм сжатия)
Спецификация включает всю информацию, необходимую для сжатия</p>
<div class="highlight"><pre><span></span>enum { null(0), (255) } CompressionMethod;
</pre></div>
</li>
<li><p class="first">master secret
48-байтный ключ, вырабатываемый членами соединения</p>
</li>
<li><p class="first">client random
32-байтное значение, вырабатываемое клиентом</p>
</li>
<li><p class="first">server random
32-байтное значение, вырабатываемое сервером</p>
</li>
</ul>
<div class="highlight"><pre><span></span>struct {
        ConnectionEnd       entity;
        PRFAlgorithm        prf_algorithm;
        BulkCipherAlgorithm bulk_cipher_algorithm;
        CipherType          cipher_type;
        uint8               enc_key_length;
        uint8               block_length;
        uint8               fixed_iv_length;
        uint8               record_iv_length;
        MACAlgorithm        mac_algorithm;
        uint8               mac_length;
        uint8               mac_key_length;
        CompressionMethod   compression_algorithm;
        opaque              master_secret[48];
        opaque              client_random[32];
        opaque              server_random[32];
} SecurityParameters;
</pre></div>
<p>На уровне записи, используя параметры, генерируются (алгоритм генерации описан далее)</p>
<ul class="simple">
<li>ключ имитовставки клиента на запись</li>
<li>ключ имитовставки сервера на запись</li>
<li>ключ шифрования клиента на запись</li>
<li>ключ шифрования сервера на запись</li>
<li>инициализирующий вектор клиента на запись</li>
<li>инициализирующий вектор сервера на запись</li>
</ul>
<p>Клиентские параметры на запись используются сервером при получении и обработке сообщений и наоборот,
соответственно.</p>
<p>После генерации ключей и установления параметров, состояния соединения могут стать текущими
состояниями. Эти текущие состояния <strong>ОБЯЗАНЫ</strong> обновляться для каждой обработанной записи.</p>
<p>Элементы состояния соединения:</p>
<ul class="simple">
<li>compression state (состояние сжатия)</li>
<li>cipher state (состояние шифрования)</li>
<li>MAC key (ключ имитовставки)</li>
<li>sequence number (номер)
Состояния соединения нумеруются (чтение и запись отдельно). Номер устанавливается нулевым, когда
состояние соединения становится активным. Номера имеют тип uint16. С каждой записью номер
увеличивается на 1.</li>
</ul>
</div>
<div class="section" id="id11">
<h2>Фрагментация</h2>
<p>Уровень записи получает данные от более высоких уровней в непустых блоках заданного размера.</p>
<p>Уровень записи фрагментирует блоки в TLSPlaintext записи (см. ниже). Размер записи не может
превышать 2^14 байт. Границы сообщения клиента не сохраняются. То есть в одной записи может
содержаться несколько сообщений или наоборот в нескольких записях может быть одно сообщение.</p>
<div class="highlight"><pre><span></span>struct {
        uint8 major;
        uint8 minor;
} ProtocolVersion;

enum {
        change_cipher_spec(20),
        alert(21),
        handshake(22),
        application_data(23),
        (255)
} ContentType;

struct {
        ContentType type;
        ProtocolVersion version; /*** TLS 1.2 uses {3,3} version ***/
        uint16 length;
        opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
</pre></div>
<p>Для содержимого типа установление соединения (handshake), тревоги (alert), изменение параметров
шифрования (change cipher spec) TLS записи не могут быть нулевой длины, а для данных (application
data) могут (например для усложнения анализа трафика).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Записи разных типов могут перемешиваться. Данные (application data), как
правило, имеют меньший приоритет. Тем не менее записи <strong>обязаны</strong> отправляться по сети в том
же порядке, в котором они проходят уровень TLS record. Получатель должен получить и
обработать перемешанные записи с данными только после завершения установления соединения.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h2>Сжатие и распаковка данных</h2>
<p>Все записи сжимаются и распаковываются в соответствии с алгоритмом, определенным в текущем
состоянии. Алгоритм сжатия и распаковки используется всегда, просто иногда он определен как
<cite>CompressionMethod.null</cite>. Алгоритм сжатия переводит <cite>TLSPlaintext</cite> запись в <cite>TLSCompressed</cite>
структуру. Алгоритм сжатия TLS описан в RFC-2749.</p>
<p>Должно использоваться сжатие без потерь, не увеличивающее длину содержимого более чем на 1024 байт.
Если при распаковке получился фрагмент, длина которого больше 2^14 байт (больше максимально
возможного), то функция распаковки должна сообщить об ошибке.</p>
<div class="highlight"><pre><span></span>struct {
        ContentType type; /*** как и TLSPlaintext ***/
        ProtocolVersion version; /*** как и в TLSPlaintext ***/
        uint16 length; /*** не больше 2^14 + 1024 ***/
        opaque fragment[TLSCompressed.length];
} TLSCompressed;
</pre></div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">В случае с <cite>CompressionMethod.null</cite> структуры TLSPlaintext и TLSCompressed совпадают.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id13">
<h2>Защита записей</h2>
<p>Функции шифрования и имитовставки преобразуют TLSCompressed структуру в TLSCiphertext. Функции
расшифрования осуществляют обратную операцию. Имитовставка имеет номер для обнаружения пропущенных
или повторяющихся сообщений.</p>
<div class="highlight"><pre><span></span>struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length; /*** не превышет 2^14 + 2048 ***/
        select (SecurityParameters.cipher_type) {
                case stream: GenericStreamCipher;
                case block:  GenericBlockCipher;
                case aead:   GenericAEADCipher;
        } fragment; /*** зашифрованный TLSCompressed.fragment ***/
} TLSCiphertext;
</pre></div>
<div class="section" id="id14">
<h3>Пустой или стандартный потоковый шифр</h3>
<div class="highlight"><pre><span></span>stream-ciphered struct {
        opaque Content[TLSCompressed.length];
        opaque MAC[SecurityParameters.mac_length];
} GenericStreamCipher;
</pre></div>
<p>Имитовставка генерируется следующим образом:</p>
<div class="highlight"><pre><span></span>  MAC(MAC_write_key, seq_num
          + TLSCompressed.type
          + TLSCompressed.version
          + TLSCompressed.length
          + TLSCompressed.fragment
  );

&quot;+&quot; - это конкатенация
</pre></div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Имитовставка вычисляется до шифрования. Потоковый шифр шифрует блок, включая MAC.
TODO:</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id15">
<h3>Блочное шифрование</h3>
<div class="highlight"><pre><span></span>struct {
        /*** вектор инициализации ***/
        opaque IV(SecurityParameters.record_iv_length];
        block-ciphered struct {
                opaque content[TLSCompressed.length];
                opaque MAC[SecurityParameters.mac_length];
                uint8 padding[GenericBlockCipher.padding_length];
                uint8 padding_length;
        };
} GenericBlockCipher;
</pre></div>
<div class="section" id="padding">
<h4>padding</h4>
<blockquote>
Дополнение plaintext до длины, кратной длине блока блочного шифра. Дополнение не может быть
длинее 255 байт. Можно делать дополнение более длинным, чем это необходимо (но не длинее
255) для предотвращение атак на протокол, основанных на анализе длин сообщений.</blockquote>
</div>
<div class="section" id="padding-length">
<h4>padding_length</h4>
<blockquote>
Длина блока padding. Составляет ровно 1 байт.</blockquote>
<p>Пусть, например, размер блока равен 8, длина содержимого 61 байт, а имитовставка имеет размер 20
байт, тогда то, что должно шифроваться имеет длину 81 байт и 1 байт отводится на длину дополнения.
Таким образом дополнение должно состоять минимум из 8*11 - (81 + 1) = 6 байт. Оно может быть и
больше: 6 + 8 байт, 6 + 8 + 8 байт, ..., 254 байта. Тогда последние 8 байт (для минимального
дополнения) GenericBlockCipher будут</p>
<div class="highlight"><pre><span></span>0x## 0x06 0x06 0x06 0x06 0x06 0x06 0x06

0x## - последний байт имитовставки
</pre></div>
</div>
</div>
<div class="section" id="aead">
<h3>AEAD шифры</h3>
<p>Аутентифицирующее шифрование (см. RFC-5116 Authenticated Encryption with Associated Data) - форма шифрования при
которой в дополнение к обеспечению конфиденциальности открытого текста, предоставляется возможность
проверки целостности и подлинности. Authenticated Encryption with Associated Data (AEAD) шифрование
предоставляет возможность проверки целостности и подлинности некоторых дополнительных данных
(также называемых дополнительные подлинные данные), которые не зашифрованы.</p>
<p>Многие приложения для обеспечения целостности используют имитовставку, а для обеспечения
конфиденциальности какой-то алгоритм шифрования. При этом используется два независимых ключа. Идея
AEAD состоит в том, чтобы заменить этот подход единым алгоритмом.</p>
<div class="highlight"><pre><span></span>struct {
        opaque nonce_explicit[SecurityParameters.record_iv_length];
        aead-ciphered struct {
                opaque content[TLSCompressed.length];
        };
} GenericAEADCipher;
</pre></div>
<p>дополнительные подлинные данные определяются следующим образом:</p>
<div class="highlight"><pre><span></span>additional_data = seq_num + TLSCompressed.type + TLSCompressed.version +
                TLSCompressed.length;

&quot;+&quot; - это конкатенация
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>Генерация ключа</h2>
<p>Главный ключ раскрывается в последовательность байт, которая разделяется на клиентский ключ на
запись, серверный ключ на запись а также клиентский и серверный ключи имитовставки на запись.
Некоторые AEAD шифры могут дополнительно нуждаться в клиентском и серверном инициализирующих
векторах.</p>
<p>раскрытие в последовательность байт:</p>
<div class="highlight"><pre><span></span>key_block = PRF(SecurityParameters.master_secret,
        &quot;key expansion&quot;,
        SecurityParameters.server_random +
        SecurityParameters.client_random);
</pre></div>
<p>разделение:</p>
<div class="highlight"><pre><span></span>client_write_MAC_key[SecurityParameters.mac_key_length];
server_write_MAC_key[SecurityParameters.mac_key_length];
client_write_key[SecurityParameters.enc_key_length];
server_write_key[SecurityParameters.enc_key_length];
client_write_IV[SecurityParameters.fixed_iv_length];
server_write_IV[SecurityParameters.enc_key_length];
</pre></div>
</div>
<div class="section" id="handshaking-protocols">
<h2>Протоколы установления соединения (handshaking protocols)</h2>
<p>Существует 3 подпротокола по которым стороны вырабатывают соглашения относительно параметров (security
parameters) соединения на уровне записи для аутентификации себя, вырабатывания начальных
параметров и сообщений об ошибках.</p>
<p>В процессе установления соединения узлы вырабатывают сессию, состоящую из следующих элементов:</p>
<ul class="simple">
<li>идентификатор сессии</li>
<li>сертификаты сторон</li>
<li>метод сжатия</li>
<li>параметры алгоритма шифрования</li>
<li>главный ключ</li>
<li>восстанавливаемость</li>
</ul>
<p>Эти элементы далее могут быть использованы для составления параметров протокола TLS записи. С
помощью данной сессии можно устанавливать множество TLS соединений.</p>
<div class="section" id="id17">
<h3>Протокол изменения параметров шифрования</h3>
<p>Протокол состоит из одного сообщения, которое шифруется и сжимается по текущему (не <em>ожидаемому</em>, а
текущему) состоянию. Сообщение состоит из одного байта 0x01.</p>
<div class="highlight"><pre><span></span>struct {
        enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;
</pre></div>
<p>Сообщение ChangeCipherSpec посылается как клиентом, так и сервером. Получатель данного сообщения
должен заменить текущее состояние чтения ожидаемым состоянием чтения, а отправитель заменяет
ожидаемое состояние записи текущим состоянием записи.</p>
<p>Сообщение ChangeCipherSpec посылается в процессе установления соединения после того как параметры
безопасности согласованы, но до посылки подтверждающего сообщения <cite>Finished</cite>.</p>
</div>
<div class="section" id="id18">
<h3>Протокол тревоги</h3>
<p>Одним из типов содержимого является тип тревоги. Сообщение тревоги содержит важность сообщения и
описание. Сообщение важности fatal незамедлительно прерывает соединение. В данном случае может
происходить какое-то общение между узлами, но идентификатор сессии становится недействительным.
Таким образом, сессия не может использоваться для установления новых соединений. Сообщение тревоги
шифруется и сжимается, как и остальные.</p>
<div class="highlight"><pre><span></span>enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
        close_notify(0),
        unexpected_message(10),
        bad_record_mac(20),
        decryption_failed_RESERVED(21),
        record_overflow(22),
        decompression_failure(30),
        handshake_failure(40),
        no_certificate_RESERVED(41),
        bad_certificate(42),
        unsupported_certificate(43),
        certificate_revoked(44),
        certificate_expired(45),
        certificate_unknown(46),
        illegal_parameter(47),
        unknown_ca(48),
        access_denied(49),
        decode_error(50),
        decrypt_error(51),
        export_restriction_RESERVED(60),
        protocol_version(70),
        insufficient_security(71),
        internal_error(80),
        user_canceled(90),
        no_renegotiation(100),
        unsupported_extension(110),
        (255)
} AlertDescription;

struct {
        AlertLevel level;
        AlertDescription description;
} Alert;
</pre></div>
</div>
<div class="section" id="id19">
<h3>Закрывающие сообщения тревоги</h3>
<p>Любая сторона может завершить соединение. Для этого она должна послать <cite>close_notify</cite>.
Сообщение <cite>close_notify</cite> говорит о том, что отправитель больше не будет посылать сообщений.
Перед закрытием соединения (если не происходило каких-то критических ошибок) закрывающая сторона в
обязательном порядке должна послать <cite>close_notify</cite>, получив <cite>close_notify</cite> необходимо послать его в
ответ, хотя закрывающая сторона вовсе не должна его дожидаться.</p>
<p>При получении сообщения тревоги с критической ошибкой соединение закрывается. При получении
сообщений типа warning соединение не должно закрываться. Если всё-таки его необходимо по какой-лдибо
причине закрыть, необходимо послать сообщение о критической ошибке. Таким образом сообщения
<cite>warning</cite> - не очень-то полезная штука и редко посылаются.</p>
<p>Определены следующие сообщения об ошибках:</p>
<p>TODO:</p>
<ul>
<li><p class="first">unexpected_message</p>
<p>An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.</p>
</li>
<li><p class="first">bad_record_mac</p>
<p>This alert is returned if a record is received with an incorrect MAC. This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it wasn’t an even multiple of the block length, or its padding values, when checked, weren’t correct. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</p>
</li>
<li><p class="first">decryption_failed_RESERVED</p>
<p>This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC mode [CBCATT]. It MUST NOT be sent by compliant implementations.</p>
</li>
<li><p class="first">record_overflow</p>
<p>A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</p>
</li>
<li><p class="first">decompression_failure</p>
<p>The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal and should never be observed in communication between proper implementations.</p>
</li>
<li><p class="first">handshake_failure</p>
<p>Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a</p>
</li>
<li><p class="first">no_certificate_RESERVED</p>
<p>This alert was used in SSLv3 but not any version of TLS. NOT be sent by compliant implementations. It MUST NOT be sent by compliant implementations.</p>
</li>
<li><p class="first">bad_certificate</p>
<p>A certificate was corrupt, contained signatures that did not verify correctly, etc.</p>
</li>
<li><p class="first">unsupported_certificate</p>
<p>A certificate was of an unsupported type.</p>
</li>
<li><p class="first">certificate_revoked</p>
<p>A certificate was revoked by its signer.</p>
</li>
<li><p class="first">certificate_expired</p>
<p>A certificate has expired or is not currently valid.</p>
</li>
<li><p class="first">certificate_unknown</p>
<p>Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable. illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This message is always fatal.</p>
</li>
<li><p class="first">unknown_ca</p>
<p>A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn’t be matched with a known, trusted CA. This message is always fatal.</p>
</li>
<li><p class="first">access_denied</p>
<p>A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.</p>
</li>
<li><p class="first">decode_error</p>
<p>A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</p>
</li>
<li><p class="first">decrypt_error</p>
<p>A handshake cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message. This message is always fatal.</p>
</li>
<li><p class="first">export_restriction_RESERVED</p>
<p>This alert was used in some earlier versions of TLS. be sent by compliant implementations. It MUST NOT be sent by compliant implementations.</p>
</li>
<li><p class="first">protocol_version</p>
<p>The protocol version the client has attempted to negotiate is recognized but not supported. (For example, old protocol versions might be avoided for security reasons.) This message is always fatal.</p>
</li>
<li><p class="first">insufficient_security</p>
<p>Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.</p>
</li>
<li><p class="first">internal_error</p>
<p>An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue. This message is always fatal.</p>
</li>
<li><p class="first">user_canceled</p>
<p>This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.</p>
</li>
<li><p class="first">no_renegotiation</p>
<p>Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert. At that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate is where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup, and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.</p>
</li>
<li><p class="first">unsupported_extension</p>
<p>sent by clients that receive an extended server hello containing an extension that they did not put in the corresponding client hello. This message is always fatal.</p>
</li>
</ul>
<p>Добавление новых ошибок производится через IANA.</p>
</div>
</div>
<div class="section" id="id20">
<h2>Протокол установления соединения (детально)</h2>
<p>Что происходит во время установления соединения</p>
<ol class="arabic simple">
<li>Обмениваемся hello сообщениями для согласования алгоритмов, обмена случайными значениями и
проверки возобновляемости сессии.</li>
<li>Обмениваемся необходимыми параметрами шифрования, вырабатываем premaster ключ</li>
<li>Обмениваемся сертификатами и информацией аутентификации</li>
<li>Генерируем общий ключ из premaster и обмениваемся случайными значениями</li>
<li>Применяем параметры к уровню записи (TLS Record)</li>
<li>Проверяем, что клиент и сервер получили одинаковые параметры безопасности и установление
соединения произошло успешно.</li>
</ol>
<p>Как происходит установление соединения</p>
<p>Клиент шлёт сообщение <cite>ClientHello</cite>, на который сервер должен ответить сообщением <cite>ServerHello</cite> (либо на
стороне сервера возникает критическая ошибка и соединение обрывается). При этом устанавливаются
следующие атрибуты: версия протокола, идентификатор сессии, набор шифров и методы сжатия.
Дополнительно генерируются два случайных значения <cite>ClientHello.random</cite> и <cite>ServerHello.random</cite>.</p>
<p>Следом за сообщениями hello сервер шлёт сертификат (сообщение Crtificate), если необходимо
подтвердить подлинность сервера. Дополнительно может быть послано ServerKeyExchange сообщение (если
у сервера нет сертификата или его сертификат может быть использован только для подписи). Если сервер
прошёл проверку подлинности, он может запросить сертификат клиента (если этого требуется в выбранной
системе шифрования). Далее сервер посылает сообщение <cite>ServerHelloDone</cite>. Это сигнализирует о том, что
этап обмена hello-сообщениями завершён. Если у клиента был запрошен сертификат, он должен его
послать. Затем клиент посылает сообщение <cite>ClientKeyExchange</cite> (содержимое сообщения зависит от
выбранного алгоритма шифрования). Если клиент послал сертификат с возможностью цифровой подписи, то
он также плсылает подписанной сообщение <cite>CertificateVerify</cite>, чтобы показать, что у него имеется
закрытый ключ для подписи.</p>
<p>Далее клиент шлет <cite>ChangeCipherSpec</cite> сообщение и подменяет текущий шифр ожидаемым, после чего
незамедлительно шлёт <cite>Finished</cite> сообщение зашифрованное новым шифром. В ответ сервер пошлёт своё
сообщение <cite>ChangeCipherSpec</cite>, меняет шифр и шлёт <cite>Finished</cite>. С этого момента установление соединения
закончено и можно обмениваться данными.</p>
<div class="highlight"><pre><span></span>Client                        Server

ClientHello        --------&gt;
                              ServerHello
                              Certificate*
                              ServerKeyExchange*
                              CertificateRequest*
                   &lt;--------  ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished           --------&gt;
                              [ChangeCipherSpec]
                   &lt;--------  Finished
Application Data   &lt;-------&gt;  Application Data

* - опционально
</pre></div>
<p>Если клиент с сервером решают продолжить предыдущую сессию или клонировать существующую (чобы не
согласовывать новые параметры безопасности), то обмен сообщениями будет строится следующим образом:</p>
<p>Клиент шлет ClientHello, используя идентификатор сессии, которую хотел бы продолжить. Сервер
проверяет свой кэш сессий в поисках нужной. Если сессия найдена, то сервер пытается установить
соединение с помощью данной сессии, он пошлёт ServerHello с тем же идентификатором сессии, они
меняют шифры посредством <cite>ChangeCipherSpec</cite> сообщений и обмениваются <cite>Finished</cite>. Если же сессия
отсутствует в кэше сервера, то производится полная процедура установления соединения.</p>
<div class="highlight"><pre><span></span>Client                        Server

ClientHello        --------&gt;
                              ServerHello
                              [ChangeCipherSpec]
                   &lt;--------  Finished
[ChangeCipherSpec]
Finished           --------&gt;
Application Data   &lt;-------&gt;  Application Data
</pre></div>
<p>Протокол установления соединения на более низком уровне использует протокол TLS записи для передачи
сообщений.</p>
<div class="highlight"><pre><span></span>enum {
        hello_request(0),
        client_hello(1),
        server_hello(2),
        certificate(11),
        server_key_exchange (12),
        certificate_request(13),
        server_hello_done(14),
        certificate_verify(15),
        client_key_exchange(16),
        finished(20), (255)
} HandshakeType;

struct {
        HandshakeType msg_type;
        uint24 length;
        select (HandshakeType) {
                case hello_request:       HelloRequest;
                case client_hello:        ClientHello;
                case server_hello:        ServerHello;
                case certificate:         Certificate;
                case server_key_exchange: ServerKeyExchange;
                case certificate_request: CertificateRequest;
                case server_hello_done:   ServerHelloDone;
                case certificate_verify:  CertificateVerify;
                case client_key_exchange: ClientKeyExchange;
                case finished:            Finished;
        } body;
} Handshake;
</pre></div>
<div class="section" id="hellorequest">
<h3>HelloRequest</h3>
<p>Сообщение <cite>HelloRequest</cite> может быть послано сервером в <strong>любой</strong> момент. Клиент не обязан отвечать,
(а может ответить и <cite>no_renegatiation</cite> сообщением тревоги), но сервер в таком случае в праве разорвать
соединение. Послав <cite>HelloRequest</cite> сервер должен дождаться какого-то результата процедуры
установления соединения.</p>
<p>Структура сообщения:</p>
<div class="highlight"><pre><span></span>struct {} HelloRequest;
</pre></div>
</div>
<div class="section" id="clienthello">
<h3>ClientHello</h3>
<p>Структура сообщения:</p>
<div class="highlight"><pre><span></span>struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;;
        select (extensions_present) {
                case false:
                        struct {};
                case true:
                        Extension extensions&lt;0..2^16-1&gt;;
        };
} ClientHello;
</pre></div>
<div class="section" id="random">
<h4>Random</h4>
<div class="highlight"><pre><span></span>struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
} Random;
</pre></div>
<ul class="simple">
<li><cite>gmt_unix_time</cite> - дата и время  в стандартном UNIX-времени (секунды с начала эпохи). TLS не
определяет, что часы должны идти правильно. Хотя приложение на более высоком уровне может
учитывать этот параметр.</li>
<li><cite>random_bytes</cite> - 28 байт, сгенерированных генератором случайных чисел.</li>
</ul>
</div>
<div class="section" id="sessionid">
<h4>SessionID</h4>
<p>Если не пусто, то продолжить сессию. Если пусто - начать новую.</p>
<div class="highlight"><pre><span></span>opaque SessionID&lt;0..32&gt;;
</pre></div>
</div>
<div class="section" id="id21">
<h4>Набор шифрования</h4>
<p>Комбинация криптоалгоритмов, поддерживаемых клиентом в порядке желательности для клиента. Каждый
&quot;набор шифрования&quot; содержит алгоритм распределения ключей, алгоритм шифрования (включая длину
закрытого ключа), алгоритм имитовставки и псевдослучайную функцию. Сервер выберет подходящий набор,
либо вернет критическую ошибку.</p>
<div class="highlight"><pre><span></span>uint8 CipherSuite[2];
</pre></div>
<p>Возможные варианты:</p>
<p>Без шифрования (может использоваться только как инициализирующее значение).</p>
<div class="highlight"><pre><span></span>CipherSuite TLS_NULL_WITH_NULL_NULL = { 0x00,0x00 };
</pre></div>
<p>Для серверов, поддерживающих RSA (должен быть сертификат):</p>
<div class="highlight"><pre><span></span>CipherSuite   TLS_RSA_WITH_NULL_MD5                ={  0x00, 0x01  };
CipherSuite   TLS_RSA_WITH_NULL_SHA                ={  0x00, 0x02  };
CipherSuite   TLS_RSA_WITH_NULL_SHA256             ={  0x00, 0x3B  };
CipherSuite   TLS_RSA_WITH_RC4_128_MD5             ={  0x00, 0x04  };
CipherSuite   TLS_RSA_WITH_RC4_128_SHA             ={  0x00, 0x05  };
CipherSuite   TLS_RSA_WITH_3DES_EDE_CBC_SHA        ={  0x00, 0x0A  };
CipherSuite   TLS_RSA_WITH_AES_128_CBC_SHA         ={  0x00, 0x2F  };
CipherSuite   TLS_RSA_WITH_AES_256_CBC_SHA         ={  0x00, 0x35  };
CipherSuite   TLS_RSA_WITH_AES_128_CBC_SHA256      ={  0x00, 0x3C  };
CipherSuite   TLS_RSA_WITH_AES_256_CBC_SHA256      ={  0x00, 0x3D  };
</pre></div>
<p>Диффи-Хэллман (у сервера должен быть серктификат, у клиента он тоже может быть запрошен).</p>
<div class="highlight"><pre><span></span>CipherSuite   TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA     ={   0x00, 0x0D   };
CipherSuite   TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA     ={   0x00, 0x10   };
CipherSuite   TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA    ={   0x00, 0x13   };
CipherSuite   TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA    ={   0x00, 0x16   };
CipherSuite   TLS_DH_DSS_WITH_AES_128_CBC_SHA      ={   0x00, 0x30   };
CipherSuite   TLS_DH_RSA_WITH_AES_128_CBC_SHA      ={   0x00, 0x31   };
CipherSuite   TLS_DHE_DSS_WITH_AES_128_CBC_SHA     ={   0x00, 0x32   };
CipherSuite   TLS_DHE_RSA_WITH_AES_128_CBC_SHA     ={   0x00, 0x33   };
CipherSuite   TLS_DH_DSS_WITH_AES_256_CBC_SHA      ={   0x00, 0x36   };
CipherSuite   TLS_DH_RSA_WITH_AES_256_CBC_SHA      ={   0x00, 0x37   };
CipherSuite   TLS_DHE_DSS_WITH_AES_256_CBC_SHA     ={   0x00, 0x38   };
CipherSuite   TLS_DHE_RSA_WITH_AES_256_CBC_SHA     ={   0x00, 0x39   };
CipherSuite   TLS_DH_DSS_WITH_AES_128_CBC_SHA256   ={   0x00, 0x3E   };
CipherSuite   TLS_DH_RSA_WITH_AES_128_CBC_SHA256   ={   0x00, 0x3F   };
CipherSuite   TLS_DHE_DSS_WITH_AES_128_CBC_SHA256  ={   0x00, 0x40   };
CipherSuite   TLS_DHE_RSA_WITH_AES_128_CBC_SHA256  ={   0x00, 0x67   };
CipherSuite   TLS_DH_DSS_WITH_AES_256_CBC_SHA256   ={   0x00, 0x68   };
CipherSuite   TLS_DH_RSA_WITH_AES_256_CBC_SHA256   ={   0x00, 0x69   };
CipherSuite   TLS_DHE_DSS_WITH_AES_256_CBC_SHA256  ={   0x00, 0x6A   };
CipherSuite   TLS_DHE_RSA_WITH_AES_256_CBC_SHA256  ={   0x00, 0x6B   };
</pre></div>
<p>Диффи-Хэллман (анонимно)</p>
<div class="highlight"><pre><span></span>CipherSuite  TLS_DH_anon_WITH_RC4_128_MD5         =  {  0x00, 0x18  };
CipherSuite  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA    =  {  0x00, 0x1B  };
CipherSuite  TLS_DH_anon_WITH_AES_128_CBC_SHA     =  {  0x00, 0x34  };
CipherSuite  TLS_DH_anon_WITH_AES_256_CBC_SHA     =  {  0x00, 0x3A  };
CipherSuite  TLS_DH_anon_WITH_AES_128_CBC_SHA256  =  {  0x00, 0x6C  };
CipherSuite  TLS_DH_anon_WITH_AES_256_CBC_SHA256  =  {  0x00, 0x6D  };
</pre></div>
<p>{ 0x00, 0x1C } и { 0x00, 0x1D } заезервированы, во избежание коллизий с SSL.</p>
</div>
<div class="section" id="id22">
<h4>Метод сжатия</h4>
<p>Обязательно должен поддерживаться режим без сжатия.</p>
<div class="highlight"><pre><span></span>enum { null(0), (255) } CompressionMethod;
</pre></div>
</div>
</div>
<div class="section" id="serverhello">
<h3>ServerHello</h3>
<div class="highlight"><pre><span></span>struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_mehtod;
        select (extensions_present ) {
                case false:
                        struct {};
                case true:
                        Extension extemsions&lt;0..2^16-1&gt;;
        };
} ServerHello;
</pre></div>
<p>В принципе, понятно как заполняется указанная структура. Некоторые замечания:</p>
<ul>
<li><p class="first">session_id</p>
<p>Если сервер вернёт нулевой <cite>session_id</cite>, это будет означать, что сессия не может быть продолжена.</p>
</li>
<li><p class="first">cipher_suite, compression_mehtod</p>
<p>Сервер должен выбрать один из предоставленных клиентом.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">note:</th><td class="field-body">Дочитав до этого момента можно уже что-то &quot;пощупать&quot; - см. SSL-практика.</td>
</tr>
</tbody>
</table>
</div>
</div>

            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="hypercomments_widget"></div>
        <script type="text/javascript">
        _hcwp = window._hcwp || [];
        _hcwp.push({widget:"Stream", widget_id: 27931});
        (function() {
        if("HC_LOAD_INIT" in window)return;
        HC_LOAD_INIT = true;
        var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
        var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
        hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/27931/"+lang+"/widget.js";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hcc, s.nextSibling);
        })();
        </script>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3 well well-sm" id="sidebar">

<aside>
    <section>
        <ul class="list-group list-group-flush">
                <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
                  <ul class="list-group" id="social">
                    <li class="list-group-item"><a href="http://www.facebook.com/hoxnox"><i class="fa fa-facebook-square fa-lg"></i> facebook</a></li>
                    <li class="list-group-item"><a href="http://twitter.com/hoxnox"><i class="fa fa-twitter-square fa-lg"></i> twitter</a></li>
                    <li class="list-group-item"><a href="http://github.com/hoxnox"><i class="fa fa-github-square fa-lg"></i> github</a></li>
                    <li class="list-group-item"><a href="http://habrahabr.ru/users/hoxnox/"><i class="fa fa-habrahabr-square fa-lg"></i> habrahabr</a></li>
                  </ul>
                </li>



                <li class="list-group-item"><a href="http://blog.hoxnox.com/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
                    <ul class="list-group list-inline tagcloud" id="tags">
                    </ul>
                </li>    



        </ul>
    </section>

</aside>        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2017 Merder hoxnox Kim <hoxnox@gmail.com>
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://blog.hoxnox.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://blog.hoxnox.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://blog.hoxnox.com/theme/js/respond.min.js"></script>

    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-29479486-1']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->
</body>
</html>