<!DOCTYPE html>
<html lang="ru"
>
<head>
    <title>Программирование сетевых приложений (TCP/IP) на C/C++ - NX</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://blog.hoxnox.com/inet/tcp_programming.html">

        <meta name="author" content="Merder hoxnox Kim <hoxnox@gmail.com>" />
        <meta name="keywords" content="UML,fork,exec,system,posix_spawn,C" />
        <meta name="description" content="Записки на тему TCP/IP и его C-шных API." />

    <!-- Enable latex plugin -->




    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://blog.hoxnox.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://blog.hoxnox.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://blog.hoxnox.com/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://blog.hoxnox.com/theme/css/style.css" type="text/css"/>

        <link href="http://blog.hoxnox.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="NX ATOM Feed"/>
        <link href="http://blog.hoxnox.com/rss.xml" type="application/rss+xml" rel="alternate"
              title="NX RSS Feed"/>


        <link href="http://blog.hoxnox.com/feeds/inet.atom.xml" type="application/atom+xml" rel="alternate"
              title="NX inet ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://blog.hoxnox.com/" class="navbar-brand">
NX            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="http://blog.hoxnox.com/category/admin.html">Admin</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/blog.html">Blog</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/chsheets.html">Chsheets</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/cxx.html">Cxx</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/devel.html">Devel</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/gentoo.html">Gentoo</a>
                        </li>
                        <li class="active">
                            <a href="http://blog.hoxnox.com/category/inet.html">Inet</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/other.html">Other</a>
                        </li>
                        <li >
                            <a href="http://blog.hoxnox.com/category/sec.html">Sec</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li><a href="http://blog.hoxnox.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
        <div class="col-sm-9">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://blog.hoxnox.com/inet/tcp_programming.html"
                       rel="bookmark"
                       title="Permalink to Программирование сетевых приложений (TCP/IP) на C/C++">
                        Программирование сетевых приложений (TCP/IP) на C/C++
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2012-04-02T00:00:00+04:00"> Пн 02 Апрель 2012</time>
    </span>






<span class="label label-default">Tags</span>
	<a href="http://blog.hoxnox.com/tag/uml.html">UML</a>
        /
	<a href="http://blog.hoxnox.com/tag/fork.html">fork</a>
        /
	<a href="http://blog.hoxnox.com/tag/exec.html">exec</a>
        /
	<a href="http://blog.hoxnox.com/tag/system.html">system</a>
        /
	<a href="http://blog.hoxnox.com/tag/posix_spawn.html">posix_spawn</a>
        /
	<a href="http://blog.hoxnox.com/tag/c.html">C</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <div class="section" id="id1">
<h2>Простейшие примеры</h2>
<div class="section" id="tcp-ip">
<h3>TCP/IP</h3>
<p>Сервер</p>
<div class="highlight"><pre><span></span><span class="cm">/* определяет типы данных */</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cm">/* &quot;Главный&quot; по сокетам */</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cm">/* sockaddr_in struct, sin_family, sin_port, in_addr_t, in_port_t, ...*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>

<span class="cm">/**@brief Получает от клиента последовательность байт, не длиннее 30 и печатает её на экран по</span>
<span class="cm"> * завершении соединения. Клиенту отправляет &quot;Hi, dear!&quot;*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
      <span class="cm">/*создаём сокет*/</span>
      <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling socket&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*определяем прослушиваемый порт и адрес*/</span>
      <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
      <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
      <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">18666</span><span class="p">);</span>
      <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">bind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling bind&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*помечаем сокет, как пассивный - он будет слушать порт*/</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">listen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling listen&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*начинаем слушать, для соединения создаём другой сокет, в котором можем общаться.*/</span>
      <span class="kt">int</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling accept&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*читаем данные из сокета*/</span>
      <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span><span class="p">(;;)</span>
      <span class="p">{</span>
              <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="mi">31</span><span class="p">);</span>
              <span class="cm">/*следует помнить, что данные поступают неравномерно*/</span>
              <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="p">{</span>
                      <span class="cm">/*чтение может быть прервано системным вызовом, это нормально*/</span>
                      <span class="k">if</span><span class="p">(</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span> <span class="p">)</span>
                              <span class="k">continue</span><span class="p">;</span>
                      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Can&#39;t receive data.&quot;</span><span class="p">);</span>
                      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
                      <span class="k">break</span><span class="p">;</span>
              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kt">char</span> <span class="n">response</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hi, dear!&quot;</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">sendto</span><span class="p">(</span> <span class="n">s1</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">response</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error sending response&quot;</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Response send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<!-- *** -->
<p>Клиент</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>
<span class="cm">/* hton, ntoh и проч. */</span>
<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>

      <span class="cm">/*объявляем сокет*/</span>
      <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span> <span class="s">&quot;Error calling socket&quot;</span> <span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*соединяемся по определённому порту с хостом*/</span>
      <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">peer</span><span class="p">;</span>
      <span class="n">peer</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
      <span class="n">peer</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span> <span class="mi">18666</span> <span class="p">);</span>
      <span class="n">peer</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="p">);</span>
      <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span> <span class="p">)</span><span class="o">&amp;</span><span class="n">peer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">peer</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span> <span class="s">&quot;Error calling connect&quot;</span> <span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*посылаем данные</span>
<span class="cm">       *</span>
<span class="cm">       * Если быть точным, данные не посланы, а записаны где-то в стеке, когда и как они будут</span>
<span class="cm">       * отправлены реализации стека TCP/IP виднее. Зато мы сразу получаем управление, не</span>
<span class="cm">       * дожидаясь у моря погоды.*/</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello, world!&quot;</span><span class="p">;</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">send</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="s">&quot;Hello, world!&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span> <span class="s">&quot;Error calling send&quot;</span> <span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* закрываем соединения для посылки данных */</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">shutdown</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling shutdown&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/* читаем ответ сервера */</span>
      <span class="n">fd_set</span> <span class="n">readmask</span><span class="p">;</span>
      <span class="n">fd_set</span> <span class="n">allreads</span><span class="p">;</span>
      <span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">allreads</span> <span class="p">);</span>
      <span class="n">FD_SET</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allreads</span> <span class="p">);</span>
      <span class="n">FD_SET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allreads</span> <span class="p">);</span>
      <span class="k">for</span><span class="p">(;;)</span>
      <span class="p">{</span>
              <span class="n">readmask</span> <span class="o">=</span> <span class="n">allreads</span><span class="p">;</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">select</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="p">{</span>
                      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling select&quot;</span><span class="p">);</span>
                      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readmask</span> <span class="p">)</span> <span class="p">)</span>
              <span class="p">{</span>
                      <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
                      <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
                      <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
                      <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                      <span class="p">{</span>
                              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Error calling recv&quot;</span><span class="p">);</span>
                              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                      <span class="p">}</span>
                      <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
                      <span class="p">{</span>
                              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Server disconnected&quot;</span><span class="p">);</span>
                              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                      <span class="p">}</span>
                      <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Hi, dear!&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                              <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Got answer. Success.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                      <span class="k">else</span>
                              <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Wrong answer!&quot;</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readmask</span> <span class="p">)</span> <span class="p">)</span>
              <span class="p">{</span>
                      <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;No server response&quot;</span> <span class="p">);</span>
                      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<!-- *** -->
</div>
<div class="section" id="udp">
<h3>UDP</h3>
</div>
</div>
<div class="section" id="tcp">
<h2>Что следует иметь ввиду при разработке с TCP</h2>
<ol class="arabic simple">
<li>TCP не выполняет опрос соединения (не поможет даже keep alive -
он нужен для уборки мусора, а не контроля за состоянием соединения). Исправляется на прикладном
уровне, например, реализацией пульсации. Причем на дополнительном соединении.</li>
<li>Задержки при падении хостов, разрыве связи.</li>
<li>Необходимо следить за порядком получения сообщений.</li>
<li>Заранее неизвестно сколько данных будет прочитано из сокета. Может быть прочитано несколько
пакетов сразу!</li>
<li>Надо быть готовым ко всем внештатным ситуациям:<ul>
<li>постоянный или временный сбой сети</li>
<li>отказ принимающего приложения</li>
<li>аварийный сбой самого хоста на принимающей стороне</li>
<li>неверное поведение хоста на принимающей стороне</li>
<li>учитывать особенности сети функционирования приложения (глобальная или локальная)</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="osi-tcp-ip">
<h2>OSI и TCP/IP</h2>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">OSI</th>
<th class="head">TCP/IP</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Прикладной уровень</td>
<td rowspan="2">Прикладной уровень</td>
</tr>
<tr><td>Уровень представления</td>
</tr>
<tr><td>Сеансовый уровень</td>
<td>Транспортный уровень</td>
</tr>
<tr><td>Транспортный уровень</td>
<td>Межсетевой уровень</td>
</tr>
<tr><td>Сетевой уровень</td>
<td rowspan="3">Интерфейсный уровень</td>
</tr>
<tr><td>Канальный уровень</td>
</tr>
<tr><td>Физический уровень</td>
</tr>
</tbody>
</table>
<!-- **|| -->
</div>
<div class="section" id="id2">
<h2>Порты</h2>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Порт</th>
<th class="head">Кем контроллируется</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0     - 1023</td>
<td>Контролируется IANA</td>
</tr>
<tr><td>1024  - 49151</td>
<td>Регистрируется в IANA</td>
</tr>
<tr><td>49152 - 65535</td>
<td>Эфимерные</td>
</tr>
</tbody>
</table>
<p>Полный список зарегистрированных портов расположен по адресу:
<a class="reference external" href="http://www.isi.edu/in-notes/iana/assignment/port-numbers">http://www.isi.edu/in-notes/iana/assignment/port-numbers</a>. Подать заявку на получение хорошо
известного или зарегистрированного номера порта можно по адресу
<a class="reference external" href="http://www.isi.edu/cgi-bin/iana/port-numbers.pl">http://www.isi.edu/cgi-bin/iana/port-numbers.pl</a>.</p>
</div>
<div class="section" id="time-wait">
<h2>Состояние TIME-WAIT</h2>
<p>После активного закрытия для данного конкретного соединения стек входит в состояние TIME-WAIT на
время 2MSL (максимальное время жизни пакета) для того, чтобы</p>
<ol class="arabic simple">
<li>заблудившийся пакет не попал в новое соединение с такими же параметрами.</li>
<li>если потерялся ACK, подтверждающий закрытие соединения, с активной стороны, пассивная снова
пощлёт FIN, активная, игнорируя TIME-WAIT уже закрыла соединение, поэтому пассивная сторона
получит RST.</li>
</ol>
<p>Отключение состояния TIME-WAIT крайне не рекомендуется, так как это нарушает безопасность TCP
соединения, тем не менее существует возможность сделать это - опция сокета SO_LINGER.</p>
<p>Штатная ситуация - перезагрузка сервера может пострадать из-за наличия TIME-WAIT. Эта проблема
решается заданием опции SO_REUSEADDR.</p>
</div>
<div class="section" id="id3">
<h2>Отложенное подтверждение и алгоритм Нейгла.</h2>
<p>Алгоритм Нейгла используется для предотвращения забивания сети мелкими пакетами и имеет очень
простую формулировку - запрещено посылать второй маленький пакет до тех пор, пока не придет
подтверждение на первый. Тем не менее данные отправляются при выполнении хотя бы одного из следующих
условий:</p>
<ul class="simple">
<li>можно послать полный сегмент размером MSS (максимальный размер сегмента)</li>
<li>соединение простаивает, и можно опустошить буфер передачи</li>
<li>алгоритм Нейгла отключен, и можно опустошить буфер передачи</li>
<li>есть срочные данные для отправки</li>
<li>есть маленьки сегмент, но его отправка уже задержана на достаточно длительное время (таймер
терпения <cite>persist timer</cite> на тайм-аут ретрансмиссии <cite>RTO</cite>)</li>
<li>окно приема, объявленное хостом на другом конце, открыто не менее чем на половину</li>
<li>необходимо повторно передать сегмент</li>
<li>требуется послать ACK на принятые данные</li>
<li>нужно объявить об обновлении окна</li>
</ul>
<p>Кроме того, существует отложенное подтверждение. При этом хост, получивший сегмент, старается
задержать отправку ACK, чтобы послать её вместе с данными.</p>
<p>Алгоритм Нейгла в купе с отложенным подтверждением в резонансе дают нежелательные задержки. Поэтому
часто его отключают. Отключение алгоритма Нейгла производится заданием опции TCP_NODELAY</p>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">on</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">on</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
<p>Но более правильным было бы проектировать приложение таким образом, чтобы было как можно меньше
маленьких блоков. Лучше писать большие. Для этого можно объединять данные самостоятельно, а можно
пользоваться аналогом write, работающим с несколькими буферами:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/uio.h&gt;</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">writev</span><span class="p">(</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">readv</span><span class="p">(</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="p">);</span>

<span class="c1">// Возвращают число переданных байт или -1 в случае ошибки</span>

<span class="k">struct</span> <span class="n">iovec</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">iov_base</span><span class="p">;</span> <span class="cm">/* Адрес начала буфера*/</span>
      <span class="kt">size_t</span> <span class="n">iov_len</span><span class="p">;</span> <span class="cm">/* Длина буфера*/</span>
<span class="p">}</span>
</pre></div>
<!-- *** -->
<p>В Winsock используется</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">WSAAPI</span> <span class="nf">WSAsend</span><span class="p">(</span> <span class="n">SOCKET</span> <span class="n">s</span><span class="p">,</span>
                    <span class="n">LPWSABUF</span><span class="p">,</span>
                    <span class="n">DWORD</span> <span class="n">cnt</span><span class="p">,</span>
                    <span class="n">LPDWORD</span> <span class="n">sent</span><span class="p">,</span>
                    <span class="n">DWORD</span> <span class="n">flags</span><span class="p">,</span>
                    <span class="n">LPWSAOVERLAPPED</span> <span class="n">ovl</span><span class="p">,</span>
                    <span class="n">LPSWSAOVERLAPPED_COMPLETION_ROUTINE</span> <span class="n">func</span> <span class="p">);</span>

<span class="c1">// Возвращает 0 в случае успеха, в противном случае SOCKET_ERROR</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_WSABUF</span> <span class="p">{</span>
      <span class="n">u_long</span> <span class="n">len</span><span class="p">;</span>     <span class="cm">/* Длина буфера */</span>
      <span class="kt">char</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">buf</span><span class="p">;</span> <span class="cm">/* Указатель на начало буфера */</span>
<span class="p">}</span> <span class="n">WSABUF</span><span class="p">,</span> <span class="n">FAR</span> <span class="o">*</span> <span class="n">LPWSABUF</span><span class="p">;</span>
</pre></div>
<!-- *** -->
</div>
<div class="section" id="connect">
<h2>Таймаут при вызове connect</h2>
<div class="section" id="alarm">
<h3>alarm</h3>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">alarm_hndlr</span><span class="p">(</span> <span class="kt">int</span> <span class="n">sig</span> <span class="p">)</span>
<span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
      <span class="c1">// ...</span>
      <span class="n">signal</span><span class="p">(</span> <span class="n">SIGALRM</span><span class="p">,</span> <span class="n">alarm_hndlr</span> <span class="p">);</span>
      <span class="n">alarm</span><span class="p">(</span> <span class="mi">5</span> <span class="p">);</span>
      <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span> <span class="p">)</span><span class="o">&amp;</span><span class="n">peer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">peer</span> <span class="p">)</span> <span class="p">);</span>
      <span class="n">alarm</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span> <span class="p">)</span>
                      <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Timeout</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
      <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<!-- *** -->
<p>Способ простой, но имеет ряд проблем.</p>
<ul class="simple">
<li>Таймер, используемый в вызове alarm не должен больше нигде применяться.</li>
<li>Перезапустить connect сразу не получится. Необходимо будет подождать, закрыть и заново открыть сокет.</li>
<li>Некоторые системы могут возобновлять connect</li>
</ul>
</div>
<div class="section" id="id4">
<h3>Неблокирующие соединения</h3>
<p>Неплохо об асинхронной работе с сокетами расписано тут:
<a class="reference external" href="http://www.wangafu.net/~nickm/libevent-book/01_intro.html">http://www.wangafu.net/~nickm/libevent-book/01_intro.html</a></p>
<p>Суть в том, чтобы использовать неблокирующие сокеты и следить за ними с помощью системных вызовов.
Жалко только, что переносимое решение &quot;из коробки&quot; можно реализовать только с тупым и медленным select.</p>
</div>
<div class="section" id="select">
<h3>select</h3>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
      <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">peer</span><span class="p">;</span>
      <span class="n">INIT</span><span class="p">()</span> <span class="c1">//</span>
      <span class="n">set_address</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">peer</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span> <span class="p">);</span>
      <span class="n">SOCKET</span> <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <span class="n">AAF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">isvalidsock</span><span class="p">(</span> <span class="n">s</span> <span class="p">)</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Socket colling error&quot;</span> <span class="p">);</span>

      <span class="cm">/* Добавляет флаг &quot;не блокирующий&quot; к флагам сокета (как дескриптора файла)*/</span>
      <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">flags</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling fcntl(F_GETFL)&quot;</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">fcntl</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling fcntl(F_SETFL)&quot;</span> <span class="p">);</span>

      <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span> <span class="p">)</span><span class="o">&amp;</span><span class="n">peer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">peer</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EINPROGRESS</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling connect&quot;</span> <span class="p">);</span>

      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="c1">// вдруг уже не надо ждать</span>
      <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">fcntl</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                      <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling fcntl (flags recovery)&quot;</span><span class="p">);</span>
              <span class="n">client</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer</span> <span class="p">);</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/* Если ждать надо, ждем с помощью select&#39;а*/</span>
      <span class="n">fd_set</span> <span class="n">rdevents</span><span class="p">;</span>
      <span class="n">fd_set</span> <span class="n">wrevents</span><span class="p">;</span>
      <span class="n">fs_set</span> <span class="n">exevents</span><span class="p">;</span>
      <span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rdevents</span> <span class="p">);</span>
      <span class="n">FD_SET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdevents</span> <span class="p">);</span>
      <span class="n">wrevents</span> <span class="o">=</span> <span class="n">rdevents</span><span class="p">;</span>
      <span class="n">exevents</span> <span class="o">=</span> <span class="n">rdevents</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
      <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">rc</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdevents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrevents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exevents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling select&quot;</span> <span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Connection timeout&quot;</span> <span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">isconnected</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdevents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrevents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exevents</span> <span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span> <span class="n">fcntl</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                      <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling fcntl (flags recovery)&quot;</span> <span class="p">)</span>
              <span class="n">client</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
              <span class="n">error</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Error calling connect&quot;</span> <span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* В UNIX и WINDOWS разные методы уведомления об успешной попытке соединения, поэтому проверка</span>
<span class="cm">вынесена в отдельную функцию.*/</span>

<span class="c1">// UNIX</span>
<span class="kt">int</span> <span class="nf">isconnected</span><span class="p">(</span> <span class="n">SOCKET</span> <span class="n">s</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">rd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">wr</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
      <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">err</span> <span class="p">);</span>
      <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/*предполагаем, что ошибки нет*/</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">rd</span> <span class="p">),</span> <span class="o">!</span><span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">wr</span> <span class="p">)</span> <span class="p">)</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">getsockopt</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">errno</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span> <span class="cm">/* если мы не соединились */</span>
      <span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Windows</span>
<span class="kt">int</span> <span class="nf">isconnected</span><span class="p">(</span> <span class="n">SOCKET</span> <span class="n">s</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">rd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">wr</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">WSASetLastError</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">rd</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">wr</span> <span class="p">)</span> <span class="p">)</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="n">ex</span> <span class="p">)</span> <span class="p">)</span>
              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<!-- *** -->
</div>
<div class="section" id="libevent">
<h3>libevent</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">TODO:</th><td class="field-body">libevent</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="sockaddr-in">
<h2>Следует обнулять структуру sockaddr_in</h2>
<p>Для дополнения структуры до 16 байт, в ней имеется блок sin_zero. Он должен быть нулевым.</p>
</div>
<div class="section" id="id5">
<h2>Преобразование порядка байт</h2>
<div class="highlight"><pre><span></span>0x12345678 =&gt; 12 34 56 78 - прямой порядок (big endian)
0x12345678 =&gt; 78 56 34 12 - братный порядок (little endian)
</pre></div>
<p>Сетевой порядок байт всегда прямой. Для преобразования числа из порядка платформы в сетевой порядок
используют <cite>hton</cite> (host to network) группу функций (<cite>htonl</cite>, <cite>htons</cite>). Обратно, соответственно <cite>ntoh</cite>.</p>
</div>
<div class="section" id="id6">
<h2>Разрешение имен и служб</h2>
<p>см. <cite>gethostbyaddr</cite>, <cite>gethostbyname</cite>, <cite>gethostbyname2</cite> (IPv6), <cite>getservbyname</cite>, <cite>getservbyport</cite></p>
</div>
<div class="section" id="boost-asio">
<h2>boost::asio</h2>
<p>Данная библиотека берет на себя ассинхронную передачу и получение сообщений по сети. Реализуется
шаблоном проектирования Proactor. На каждое событие получения ответа или отправки запроса вешается
обработчик. Операции вводавывода осуществляются асинхронно, но события формируются в очередь и
выполняются последовательно. Таким образом, вы получаете возможность писать код не заморачиваясь на
аспектах многопоточного программирования, собирая сливки с асинхронной передачи данных по сети.</p>
<p>Лучше всего о boost::asio написано в документации. В качестве простого примера выступает проект
&quot;Курсор&quot;.</p>
</div>
<div class="section" id="id7">
<h2>Количество открытых соединений</h2>
<p>Итак, допустим мы хотим удержать максимально возможное число соединений. Сколько же это? Первым
параметром, в который мы уткнёмся - число одновременно открытых файлов на процесс операционной
системы.</p>
<div class="highlight"><pre><span></span>ulimit -a | grep open
</pre></div>
<p>Следующая команда меняет это число в пределах сессии:</p>
<div class="highlight"><pre><span></span>ulimit -n 1048576
</pre></div>
<p>Откуда берется константа - не знаю. В моей системе было так. Следует отметить, что для исполнения
нужны специальные права.</p>
<p>Далее следует обратить внимание на количество оперативной памяти и иметь ввиду, что каждое открытое
соединение откушает около 64Кб unswappable памяти. Таким образом, в моём случае:</p>
<div class="highlight"><pre><span></span>python -c&quot;print(`free | awk &#39;/-\/+.*/ {print $4}&#39;`/64)&quot;
</pre></div>
<p>эта цифра была более 243422.0625. Значит будем пробовать открыть 200000 соединений. Не совсем всё
так просто. Существует целый ряд настроек в net.ipv4.tcp (/proc/sys/net/ipv4).</p>
<ul>
<li><p class="first"><cite>tcp_mem</cite> - векторная величина (минимум, нагрузка, максимум), характеризующая общие настройки
потребления памяти для протокола TCP. Измеряется в страницах (обычно страница - 4Кб). До минимума
операционная система ничего не делает, при среднем - старается ограничить использование памяти.
Максимум - максимальное число страниц, разрешённое для всех TCP сокетов. Так как мы замахиваемся
на 200000 соединений, нам надо бы минимум (200000*64)/4 = 3200000. Зачем заставлять нервничать
операционную систему.</p>
<div class="highlight"><pre><span></span>sudo sysctl -w net.ipv4.tcp_mem=&quot;3200000 3300000 3400000&quot;
</pre></div>
</li>
<li><p class="first"><cite>tcp_syncookies=0</cite> - согласно рекомендациям разработчиков ядра
(<a class="reference external" href="http://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">http://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt</a>) этот режим лучше отключить на
сильной нагрузке</p>
</li>
<li><p class="first"><cite>net.ipv4.netfilter.ip_conntrack_max=1048576</cite> - максимальное число соединений для работы механизма
connection tracking (используется, к примеру в iptables).</p>
</li>
<li><p class="first"><cite>net.ipv4.tcp_no_metrics_save=1</cite> не сохранять результаты измерений TCP соединения в кеше при его
закрытии. В некоторых случаях помогает повысить производительность.</p>
</li>
<li><p class="first"><cite>net.ipv4.tcp_tw_reuse=1</cite> разрешаем повторное использование TIME-WAIT сокетов в случаях, если
протокол считает это безопасным.</p>
</li>
<li><p class="first"><cite>net.core.somaxconn=200000</cite> максимальное число открытых сокетов, ждущих соединения.</p>
</li>
<li><p class="first"><cite>net.core.netdev_max_backlog=1000</cite> максимальное количество пакетов в очереди на обработку, если
интерфейс получает пакеты быстрее, чем ядро может их обработать.</p>
</li>
</ul>
<p>Итоговый скрипт подстройки ОС Linux</p>
<div class="highlight"><pre><span></span>#!/bin/bash

ulimit -n 1048576
MAX_SOCKS=`python -c&quot;print(\`free | awk &#39;/-\/+.*/ {print $4}&#39;\`//64&quot;`
let MAX_SOCKS_MIDLE=$MAX_SOCKS+1000
let MAX_SOCKS_UP=$MAX_SOCKS+2000
sysctl -w net.ipv4.tcp_mem=&quot;$MAX_SOCKS $MAX_SOCKS_MIDLE $MAX_SOCKS_UP&quot;
sysctl -w net.ipv4.tcp_syncookies=0
sysctl -w net.ipv4.netfilter.ip_conntrack_max=1048576
sysctl -w net.ipv4.tcp_no_metrics_save=1
sysctl -w net.ipv4.somaxconn=$MAX_SOCKS
sysctl -w net.ipv4.core.netdev_max_backlog=1000
sysctl -w net.ipv4.tcp_tw_recycle=0
sysctl -w net.ipv4.tcp_tw_reuse=0
</pre></div>
<div class="section" id="id8">
<h3>Отслеживание соединений</h3>
<p>Выше для отслеживания состояния соединения мы использовали select. К сожалению он имеет жесткое
ограничение по количеству отслеживаемых элементов. Существуют другие подходы, но к сожалению они не
кросс-платформенные. Можно использовать библиотеку libevent. Заявляется, что она использует
максимально эффективную реализацию для данной системы, но писать придётся в событийной модели.</p>
<p>Ещё один интересный момент. Стек TCP/IP Linux (3.3.8) в рамках одного потока идентифицирует соединение не только по
локальному адресу, но и по удаленному. Это позволяет а одном потоке использовать два сокета с
одним локальным адресом и портом, но разными удаленными адресами. К сожалению, при использовании
большого количества соединений возникают различные сайд-эффекты. В связи с этим придется вручную
контроллировать раздачу портов для reusable сокетов.</p>
</div>
</div>
<div class="section" id="id9">
<h2>Библиография</h2>
<p>Эффективное программирование TCP/IP ( Йон Снейдер )
<a class="reference external" href="http://ru.fractalizer.ru/frpost_197">http://ru.fractalizer.ru/frpost_197</a>/настройка-ядра-linux-для-поддержки-большо/</p>
</div>

            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="hypercomments_widget"></div>
        <script type="text/javascript">
        var _hcp = _hcp || {};_hcp.widget_id = 2153;_hcp.widget = "Stream";
        (function() {
        var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
        hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://widget.hypercomments.com/apps/js/hc.js";
        var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hcc, s.nextSibling);
        })();
        </script>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3 well well-sm" id="sidebar">

<aside>
    <section>
        <ul class="list-group list-group-flush">
                <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
                  <ul class="list-group" id="social">
                    <li class="list-group-item"><a href="http://www.facebook.com/hoxnox"><i class="fa fa-facebook-square fa-lg"></i> facebook</a></li>
                    <li class="list-group-item"><a href="http://twitter.com/hoxnox"><i class="fa fa-twitter-square fa-lg"></i> twitter</a></li>
                    <li class="list-group-item"><a href="http://github.com/hoxnox"><i class="fa fa-github-square fa-lg"></i> github</a></li>
                    <li class="list-group-item"><a href="http://habrahabr.ru/users/hoxnox/"><i class="fa fa-habrahabr-square fa-lg"></i> habrahabr</a></li>
                  </ul>
                </li>



                <li class="list-group-item"><a href="http://blog.hoxnox.com/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
                    <ul class="list-group list-inline tagcloud" id="tags">
                    </ul>
                </li>    



        </ul>
    </section>

</aside>        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Merder hoxnox Kim <hoxnox@gmail.com>
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://blog.hoxnox.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://blog.hoxnox.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://blog.hoxnox.com/theme/js/respond.min.js"></script>

    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-29479486-1']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->
</body>
</html>